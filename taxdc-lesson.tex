%\vten

%\section{Discussion}

\section{LC bugs vs. DC bugs}

We now compare LC bugs and DC bugs to identify their similarities and differences.
There are clearly similarities between LC bugs and DC bugs, as, 
by definition, they are both timing-related non-deterministic bugs.
Many DC bugs contain LC components:
untimely messages may lead to unsynchronized accesses from 
multiple threads or multiple event-handlers 
\cite{vechev.oopsla13,satish.pldi14} in a single machine.
It is probably not a surprise that atomicity violations
and order violations are two dominant triggering timing conditions
for both LC and DC bugs (Finding {\bf \#1}). 
Our observation of the small triggering scope of most DC bugs
(Finding {\bf \#3})
is similar with that for LC bugs, which may be related to the nature
of the bug sets ---
more complicated bugs may be more difficult to fix, and
hence less likely to be included in empirical studies. 

There are also many differences between LC bugs and DC bugs, as they originate
from different programming paradigms and execution
environments. For example, order violations are much more common in DC bugs
than those in LC bugs (Finding {\bf \#1}); faults and reboots are much 
more common in DC bugs than those in LC bugs (Finding {\bf \#2}); 
the diagnosis of many DC bugs will have to reason beyond one node, 
clearly different from that of LC bugs (Finding {\bf \#4});
the fix
strategies for DC bugs are very different from those of LC bugs, because
enforcing global synchronization is difficult (Finding {\bf \#5}).
