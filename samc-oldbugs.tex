


\subsection{Speed in Finding Old Bugs}
\label{eval-oldbugs}




\input{code-oldbugs}

This section evaluates the speed of SAMC vs. state-of-the-art
techniques in finding old deep bugs.  In total, we have reproduced
\numOldDeepBugs\ old deep bugs (\numZkDeepBugs\ in ZooKeeper,
\numMrDeepBugs\ in Hadoop, and \numCsDeepBugs\ in Cassandra).
Figure~\ref{code-oldbugs} illustrates the complexity of the deep bugs
that we reproduced.

\input{tab-oldbugs}

Table~\ref{tab-oldbugs} shows the result of our comparison.  We
compare SAMC with basic techniques (DFS and Random) and advanced
state-of-the-art techniques such as black-box DPOR (``bDP'') and
Random+bDP (``rDP'').  Black-box DPOR is the \modist-style of DPOR
(\sec\ref{mot-state}).  We include Random+DPOR to mimic the way
\modist\ authors found bugs faster (\sec\ref{mot-summ}).  The table
shows the number of executions to hit the bug.  As a note,
software model checking with the inclusion of failures
takes time (back-and-forth communications between the target system
and the dmck server, killing and restarting system processes multiple
times, restarting the whole system from a clean state, \etc).  On
average, each execution runs for \numAvgExecTime\ seconds and involves
a long sequence of 20-120 events including the necessary crashes and
reboots to hit the bug.  We do not show the result of running DFS
because it never hits most of the bugs.  


Based on the result in Table~\ref{tab-oldbugs}, we make several
conclusions.
%
First, with SAMC, we prove that smart systematic approaches can reach
to deep bugs quickly.  We do not need to revert to randomness or
incorporate checkpoints.  As a note, we are able to reproduce every
deep bug that we picked; we did not skip any of them.
%
(Hunting more deep bugs is possible, if needed).

Second, SAMC is one to two orders of magnitude faster compared to
state-of-the-art techniques.  Our speed-up is up to
\numMaxBugSpeedUp\ (\numAvgBugSpeedUp\ on average).  But most
importantly, there are bugs that other techniques cannot find even
after 5000 executions (around 2 days). Here, SAMC's speed-up factor is
potentially much higher (labeled with ``\uu'').  Again, in the context of
dmck (a process of hours/days), large speed-ups matter.  In many
cases, state-of-the-art policies such as bDP and rDP cannot reach the
bugs even after very long executions.  The reasons are the two
problems we mentioned earlier (\sec\ref{mot-summ}).  Our
micro-analysis (not shown) confirmed our hypothesis that non-SAMC
policies frequently make redundant crash/reboot injections and event
re-orderings that anyway lead to insignificant state changes.

Third, Random is truly ``random''.  Although many previous dmcks
embrace randomness in finding bugs~\cite{Killian+07-LifeDeathMaceMC,
  Yang+09-Modist}, when it comes to failure-induced bugs, we have a
different experience.  Sometimes Random is as competitive as SAMC
(\eg, \zkb{975}), but sometimes Random is much slower (\eg,
\zkb{1419}), or worse Random sometimes did not hit the bug (\eg,
\zkb{1492}, \mrb{5505}).  We find that some bugs require crashes
and/or reboots to happen at very specific points, which is
probabilistically hard to reach with randomness.  With SAMC, we show
that being systematic and semantic aware is consistently effective.

