

\section{Implementation and Integration}
\label{sec-impl}



%To make them scale-checkable on one machine, we added \locCass, \locRiak,
%and \locVold LOC respectively.


\input{tab-loc}





Table \ref{tab-loc} quantifies our efforts
in integrating \sck 
to four variety of distributed systems, 
Cassandra \cite{Lakshman+09-Cassandra}, 
HDFS \cite{HDFSWeb}, 
Riak \cite{RiakWeb}, and
Voldemort \cite{VoldemortWeb}.
%
The implementation of \sck involves three parts:
%
{\bf (a)} the generic program analysis tools in including \sfind and
\sfindp,
%
{\bf (b)} the new test cases we wrote to 
exercise scale-dependent loops (not covered in existing unit tests),
%
{\bf (c)} changes to make the target system ``\stest-able'' (\ie,
supporting SPC, MFR, and GEDA; \sec\ref{sc-test}),\footnote{As an analogy,
  part (b) is similar to specific \tss{fsck}s (\eg, \tss{fsck.ext4},
  \tss{fsck.xfs}) while part (c) is similar to how file system code is
  modified to make \tss{fsck} fast \cite{Henson+06-Chunkfs, Ma+13-Ffsck}.}
%
{\bf (d)} the generic \stest library including
pre-memoization, auto PIL insertion, and message order determinism support.
%


We built \sfind for Java programs (Cassandra, HDFS, and Voldemort) with
Eclipse JDT AST Parser.  For Riak (in Erlang), so far we manually insert
the PIL support.  We leave porting \sfind to Erlang's front-end parsers
\cite{Erlang-Elvis, Erlang-Dialyzer} as future work.
%
We annotated 7 data structures in Cassandra, 
5 in HDFS, and 1 in Voldemort (1 LOC per annotation).
% if have space
%\footnote{Scale-dependent data structures in
%  Cassandra: \xxx (explanation), \xxx, \xxx, ; in HDFS: \xxx
%  (explanation), \xxx, \xxx.}, respectively, in less than \xxx LOC.


%Overall, our modifications add 2-4\% of code that provide a new powerful
%functionality.


\vni {\bf Generality:} We show the generality of \sck with two major
efforts.  First, we scale-checked a total of \numProt protocols:
%
\numProtCass Cassandra (bootstrap, scale-out, decommission),
%
\numProtHDFS HDFS (write, decommission, full and incremental block reports),
%
\numProtRiak Riak (bootstrap+rebalance), and 
%
\numProtVold Voldemort (rebalancing) protocols.
%
A protocol can be built on top of other protocols (\eg, bootstrap on
gossip and failure detection protocols).



Second, for reproducing old bugs, we ported \sck to a total of \numVersOld
old releases:
%
\numVersCass Cassandra (v0.8.9, v1.1.10, v1.2.0, v1.2.9),
%
\numVersHDFS HDFS (v0.12.3, v0.19.0, 0.23.6, 2.0.0),
\numVersRiak Riak (v0.14.2), and
%
\numVersVold Voldemort (v0.90.1).
%
For finding new bugs, we also ported \sck to \numVersNew recent releases
(Cassandra v2.2.5, HDFS v2.7.3, Riak v.2.1.3, and Voldemort v1.10.21)



\vni {\bf Integration time:}
%
Table \ref{tab-loc} shows \sck\ requires
hundreds to thousands of LOC (mostly in the re-usable program analysis
and library), which we
believe is a justified cost for supporting scale-checkability.  In our
experience, after the complete \sck integration is solid for a version of
a target system, migration to another version only takes 1-2 weeks.
%
As mentioned before, we expect \sck integration can be done seamlessly
with today's DevOps practice \cite{Limoncelli+11-Devops}, where developers
are testers and testers are developers.



