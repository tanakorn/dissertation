%State of the art does not help.

As we discuss in Section \ref{sec-bg-dmck}, a recent popular approach to unearth
DC bugs is adopting distributed system model cheker or dmck. However, due to the
complexity of DC bugs that we discussin Chapter \ref{chp-taxdc} (\eg,
interactions of multiple protocols, and various and multiple faults), the state
of the art of dmcks still cannot work effectively \xxx{cite Modist, dbug,
demeter, macemc}. We observe that the existing systematic reduction policies
cannot find bugs quickly, and cannot scale with the inclusion of fault events.

In this chapter, we discuss how to advance the state of the art by leveraging
semantic awareness to assist model checking, and introduce ``Semantic-Aware
Model Checking'' (SAMC), a white-box model checking approach that takes semantic
knowledge of how events (\eg, messages, crashes, and reboots) are processed by
the target system and incorporates that information in reduction policies. We
first discuss background of dmck and the state of the art in Section \ref{dmck}

%To show the intuition
%behind SAMC, we first give an example of a simple leader election protocol.
%Then, we present SAMC architecture and our four reduction policies.

\section{Semantic Awareness}

In a simple leader election protocol, every node broadcasts its vote to reach a
quorum and elect a leader.  Each node begins by voting for itself (\eg, \ntwo\
broadcasts \ts{vote=2}).  Each node receives vote broadcasts from other peers
and processes every vote with this simplified code segment below.  As depicted
in the code segment below, if an incoming vote is less than the node's current
vote, it is simply discarded.  If it is larger, the node changes its vote and
broadcasts the new vote.

\begin{alltt}
if (msg.vote < myVote) \{
  discard;
\} else \{
  myVote = msg.vote; broadcast(myVote);
\}
\end{alltt}

Let's assume \nfour\ with \ts{vote=4} is receiving three concurrent messages
with votes \ts{1}, \ts{2}, and \ts{3} from its peers.  Here, a dmck with a
black-box DPOR approach must perform 6 (3!) orderings (\ts{123}, \ts{132}, and
so on).  This is because a black-box DPOR does {\em not} know the {\em message
processing semantic} (\ie, how messages will be processed by the receiving
node).  Thus, a black-box DPOR must treat all of them as dependent
(\sec\ref{mot-state}); they must be re-ordered for soundness.  However, by
knowing the processing logic above, a dmck can soundly conclude that all
orderings will lead to the same state; all messages will be discarded by \nfour\
and its local state will not change.  Thus, a semantic-aware dmck can reduce the
6 redundant executions to just 1 execution.

The example above shows a scalability limitation of a black-box dmck.
Fortunately, simple semantic knowledge has a great potential in removing
redundant executions.  Furthermore, semantic knowledge can be incorporated on
top of sound model checking foundations such as DPOR and symmetry, as we
describe next.
