


% ---------------------------------
\subsection{Crash Recovery Symmetry (CRS)}
\label{sam-crs}


% RS Extra note
Before we discuss our next reduction policy, we emphasize again the
difference between message event and crash/reboot event.  Message
events are generated by the target system, and thus dmck can only
reduce the number of re-orderings (but it cannot reduce the events).
Contrary, crash events are generated by dmck, and thus there exists
opportunities to reduce the number of injected crashes.  For example,
in Figure~\ref{fig-pol}c, in addition to crashing \ftri, the dmck can
also crash \fone\ and \ftwo\ in different executions, but that might
not be necessary.

\input{code-crash}

% intuition: no individual node Ids, recovery depends on different states
To omit redundant crashes, we develop crash recovery symmetry (CRS).
The intuition is that some crashes often lead to symmetrical recovery
behaviors.  For example, let's assume a 4-node system with node
roles \ts{FFFL}.  At this state, crashing the first or second or third
node perhaps lead to the same recovery since all of them are
followers, and thereby injecting one follower crash could be enough.
Further on, if the system enters a slightly different
state, \ts{FFLF}, crashing any of the followers might give the same
result as above.  However, crashing the leader in the two cases
(\nfour\ in the first case and \ntri\ in the second) should perhaps be
treated differently because the recovery might involve the dead leader
ID.  The goal of CRS is to help dmck with crash decision.


% challenge
The main question in implementing CRS is: how to incorporate crash
recovery semantics into dmck?  Our solution is to compute {\em recovery
abstract global state} (\rags), a simple and concise representation of
crash recovery.  CRS builds \rags\ with the following steps:

First, we define that two recovery actions are symmetrical if they
produce the same messages and change the same local states in the same
way.

Second, we extract recovery logic from the code by flattening the
predicate-recovery pairs (\ie, recovery-related \ts{if} blocks).
Figure~\ref{code-crash} shows a simple example.  Different recovery
actions will be triggered based on which recovery predicate
(\prone, \prtwo, or \prtri) is true.  Each predicate depends on the
local state and the information about the crashing node.  Our key here
is to map each predicate-recovery pair to this formal pattern:


\vmintwo
{\small
\begin{alltt}
    if (\pri(ls, C.ls)) 
       modify(\ralsi); 
       \textit{(and/or)}
       sendMsg(\ralsi);
\end{alltt}
}
\vmintwo

Here, \pri\ is the recovery predicate for the i-th recovery action, and 
\ralsi\ is the recovery abstract local state 
(\ie, a subset of all fields of the local state involved in 
recovery).  That is, each recovery predicate defines what recovery
abstract local state that matters (\ie, \pri$\rightarrow$\{\ralsi\}).  For example, in Figure~\ref{code-crash},
if \prone\ is true, then \ralsone\ only contains the \ts{follower}
variable; if \prtri\ is true, \ralstri\ contains \ts{role}
and \ts{leaderId} variables.

Third, before we crash a node, we check which \pri\ will be true on
each surviving node and then obtain the \ralsi.  Next, we combine
\ralsi\ of all surviving nodes and {\em sort} them into a recovery
abstract global state (\rags);  sorting \rags\ helps us exploit
topological symmetry (\eg,  individual node IDs often do not matter).


Fourth, given a plan to crash a node, the algorithm above 
gives us the \rags\ that represents the corresponding recovery action.
We also maintain a history of \rags\ of previous injected crashes.
If the \rags\ already exists in the history, then the crash is skipped
because it will lead to a symmetrical recovery of the past.


% here here here
To recap with a concrete example, let's go back to the case
of \ts{FFFL} where we plan to enable crash(\none).  Based on the code
in Figure~\ref{code-crash}, the \rags\ is \{*, $\oslash$,
$\oslash$, \ts{\#follower=3}\}; 
* implies the crashing node, 
$\oslash$ means there is no true
predicate at the other two follower nodes, and \ts{\#follower=3} comes
from \ralsone\ of \prone\ of \nfour\ (the leader).  CRS will sort this
and check the history, and assuming no hit, then crash(\none) will be
enabled.  In another execution, SAMC finds that crash(\ntwo)
at \ts{FFFL} will lead to \rags:\{$\oslash$, *,
$\oslash$, \ts{\#follower=3}\}, which after sorting will hit the
history, and hence crash(\ntwo) is skipped.  If the system enters a
different state \ts{FFLF}, no follower crash will be injected, because
the \rags\ will be the same as above.  In terms of leader crash,
crashing the leader in the two cases will be treated differently
because in a leader crash, \prtri\ is true on followers and \prtri\
involves \ts{leaderId} which is different in the two cases.

% ...
In summary, the foundation of CRS is the computation of recovery
abstract global state (\rags) from the crash recovery logic extracted
from the target system via the \pri$\rightarrow$\{\ralsi\} pattern.
We believe this extraction method is simple because CRS does {\em not}
need to know the specifics of crash recovery; CRS just needs to know
what variables are involved in recovery (\ie, the \rals) .


