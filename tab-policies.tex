


\begin{sidewaystable*}[t]
\begin{center}
{\small
%---------------------------------
\begin{tabular}{p{1.9in}|p{2in}|p{2.1in}|p{2in}} 


\multicolumn{1}{c|}{{\bf Local-Message}} &
\multicolumn{1}{c|}{{\bf Crash-Message}} &
\multicolumn{1}{c|}{{\bf Crash Recovery}} &
\multicolumn{1}{c}{{\bf Reboot Synchronization}}
\\

\multicolumn{1}{c|}{{\bf Independence (LMI)}} &
\multicolumn{1}{c|}{{\bf Independence (CMI)}} &
\multicolumn{1}{c|}{{\bf Symmetry (CRS)}} &
\multicolumn{1}{c}{{\bf Symmetry (RSS)}}
\\


\hline  % =====================================================

% ----------------------------------------------- ZLE, LMI (1)

\vminten
{\footnotesize
\begin{alltt}
bool pd : !newVote(m, s);

bool pm : newVote(m, s);

bool newVote(m, s) : {
 if (m.ep > s.ep) 
   return true; 
 else if (m.ep == s.ep)
  if (m.tx > s.tx) 
   return true;
  else if (m.tx == s.tx &&
           m.lid > s.lid) 
   return true;
}
\end{alltt}
}

& % ----------------------------------------------- ZLE, CMI (1)

\vminten
{\footnotesize
\begin{alltt}
bool pg (s, X) : 
 if (s.rl == F && X.rl == L)
  return true;
 if (s.rl == L && X.rl == F
     && !quorumAfterX(s)
  return true;
 if (s.rl == S && X.rl == S) 
  return true;

bool pl (s, X) :
 if (s.rl == L && X.rl == F 
     && quorumAfterX(s)) 
  return true;

bool quorumAfterX(s) :
  ret ((s.fol-1) >= 
        s.all/2);
\end{alltt}
}

& % ----------------------------------------------- ZLE, CRS (1)

\vminten
{\footnotesize
\begin{alltt}
bool pr1(s,C):
 if (s.rl == L && C.rl == F
     && quorumAfterX(s))
  return true;
rals1:\{rl,fol,all\};

bool pr2(s,C):
 if (s.rl == L && C.rl == F 
     && !quorumAfterX(s))
 return true;
rals2: \{rl,fol,lid,ep,tx,clk\}

bool pr3(s,C):
 if (s.rl == F && c.rl == L)
  return true;
rals3: \{rl,fol,lid,ep,tx,clk\}

bool pr4:
 if (s.rl == S)
  return true;
rals4: \{rl,lid,ep,tx,clk\}
\end{alltt}
}


& % ----------------------------------------------- ZLE, RSS (1)

\vminten
{\footnotesize
\begin{alltt}
bool ps1(s,R):
 if (s.rl == L)
  return true;
sals1: \{rl,lid,ep,tx,clk\}

bool ps2(s,R):
 if (s.rl == F)
  return true;
sals2: \{rl,lid,ep,tx,clk\}

bool ps3(s,R):
 if (s.rl == S && 
     s.clk > R.clk)
  return true;
sals3: \{rl,lid,ep,tx,clk\}

bool ps4(s,R):
 if (s.rl == S && 
     moreUpdated(s, R))
  return true;
sals4: \{rl,lid,ep,tx,clk\}

bool moreUpdated(s, R):
 if (R.ep > s.ep)
  return true;
 else if (R.ep == s.ep)
  if (R.tx > s.tx) 
   return true;
  else if (R.tx == s.tx)
   if (R.lid > s.lid)
    return true;
\end{alltt}
}

\end{tabular}
}
%---------------------------------
\end{center}
%
\vminfive
\mycaption[Protocol-Specific Reduction Rules for ZLE]{tab-policies}{Protocol-Specific Reduction Rules for ZLE}{
%
The code above shows the actual protocol-specific rules for
ZLE protocol.  These rules are the inputs to the four reduction policies.
%
Many variables are abbreviated (ep: epoch, tx: latest
transaction ID, lid: leader ID, rl: role, fol: follower count, all: total
node count, clk: logical clock, L: leading, F: following, S: searching,
X/C: crashing node, R: rebooting node). LMI \pc\ and \pi\ predicates are not 
used for ZLE, but used for other protocols. 
%
}
%\vminfive
\end{sidewaystable*}


\if 0
zle-specific rule = 49
zab-specific rule = 33
mapreduce: 35 ..
protocol average = 
\fi
