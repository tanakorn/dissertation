\chapter{Conclusion and Future Work}
\label{chp-con}

\section{Summary}

In this dissertation, we aim to unearth hidden bugs in cloud-scale distributed
systems that weaken reliability and scalability of the systems. For reliability
bugs, we focus in distributed concurrency (DC) bugs. For scalability bugs, we
focus in CPU-intensive protocol bug.

%We started our work by performing bug studies. Based on our initial work for
%cloud bug study, we dissect DC bugs and study their critical characteristics.
%Then we look at scalability bugs that are related 

The key idea for unearthing DC bugs is advancing model checking techniques for
dmcks to tackle state-space explosion. Because existing dmcks treat every target
system as a complete \textit{black box}, and therefore perform unnecessary
reorderings of distributed events that would lead to the same explored states
(\ie, redundant executions).  To tackle the problem, we introduced
Semantic-Aware Model Checking (SAMC), a novel white-box model checking approach
that takes \textit{semantic knowledge} of how distributed events (specifically,
messages, crashes, and reboots) are processed by the target system and
incorporates that information in reduction policies. The policies are based on
sound reduction techniques such as DPOR and symmetry.

And for scalability bugs, we believe from the study that we need to scale check
distributed system implementation at real scale, not via simulation nor
extraploation. Our proposed solution is to colocate as many nodes as possible
(\eg, hundreds) on one machine without sacrificing accuracy by {\em emulate}
hardware resources such that the individual nodes behave as if they run on
independent machines. We propose four emulation concepts to mitigate hardware
contention problems. We are exploring these concepts to build scale check
methodology for cloud-scale distributed systems.

\section{Future Work}
\label{sec-future}

In this work we have built a number of reduction policies that exploit simple
message processing patterns, failure recovery patterns (\eg, discard pattern,
local-only update pattern), and reboot synchronization patterns. There are two
follow-up questions to ask.  First, what and how much semantic knowledge can
advance dmck reduction policies?  Second, How to extract that semantic knowledge
automatically from the target system? We will address these two questions in
this chapter. In addition, we will discuss about finding bugs that caused by
both local and distributed interleaving.

\subsection{Broad SAMC}
Ideally we want to expose as much as semantic knowledge that can help dmck
unearth deep bugs without sacrificing soundness. With current SAMC we believe we
have only addressed the surface of the power of semantic-awareness for dmck.  We
will continue digging the semantic-awareness to push SAMC to become broader or
we call it ``Broad SAMC'', a dmck that incorporates a much broader semantic
knowledge to find deep bugs in several distributed protocols. 

To begin with, We will start by applying SAMC in model checking various kind of
distributed systems. By learning how messages and failures are processed in a
diverse set of distributed protocols, we will come up with a much broader generic
semantic knowledge that can be incorporated into dmck.

Next, with many type of fault-injection mechanisms, we will exercise more
complex failures (\eg, timeouts, disk failures). Although we have exercised
crashes and reboots in current SAMC, and gained some understanding of crash
recovery and reboot semantics which helped us create policies that reduce
unnecessary crashes and reboots and their re-orderings. But, failures are
diverse and bugs can manifest from a variety of failures such as timeout events
(\mr{3596}, \mr{4833}). The current SAMC cannot find these bugs yet, so we need
to exercise timeouts and understand the interaction between them and other
distributed events and incorporate the knowledge to dmck reduction policies.
Overall, by exercising diverse failures (\eg, timeouts, disk failures) and
building reduction policies that covers more type of failures, we will unearth
more deep bugs.

\subsection{Auto SAMC}
To answer the second question, how to extract semantic knowledge automatically
from the target system, we have considered our current approach to extract
knowledge. So far SAMC requires developers to manually extract semantic
knowledge for dmck and write the corresponding reduction policies manually. This
manual step is based on high-level human understanding of the code, which can be
error-prone. The developers can also introduce human errors when writing
reduction policies and breaks soundness. Thus, when the current SAMC does not
find bugs, it does not imply systems are bug-free; some bugs might be
accidentally missed my wrong policies.  Currently, there is no way to verify
that the semantics used for pruning out executions is correct.

To address these limitations, we propose ``Auto SAMC'', a dmck that automatically
extracts useful semantic knowledge to build reduction policies. To achieve this
goal, we will create an advanced source code analysis tool that combines
symbolic execution and SAMC. Symbolic execution generates constraints at
condition statements that define predicate values leading to true and false
conditions. The collection of condition constraints leading to a specific path
in the code is called a path constraint. Others have used symbolic execution to
target system problems ~\cite{Bucur+14-SymbolicExecution}, but Auto SAMC is
different. For instance, we want to build path constraints that lead to state
updates but whose states stay the same regardless of the reordering (\eg,
discard, increment, commutative patterns) or path constraints that lead to
state-update independence. Each path constraint can be a function of the local
state of each node and the messages the node receives. Generating such a path
constraint will require a symbolic execution tool with additional new supports.

\subsection{LocDist SAMC}
Some bugs in distributed systems are caused by interleavings of local and
distributed events such as \mr{3721}; this kind of bugs exacerbates the
state-space explosion problem. This is an unsolved problem. We do not see any
work touch these two types of events together; we know only one work that
concerns local interleavings ~\cite{Guo+11-Demeter}; here, the authors use a
technique called dynamic-interface reduction (DIR) which essentially caches and
replays global re-ordering inputs and outputs without re-running them when the
local interleavings produce the same global messages. 

To address the problem of local and distributed interleavings, We will build
``LocDist SAMC'', a dmck that incorporates both interleavings and use both local
and distributed processing semantic awareness to reduce the number of
re-orderings. We will build LocDist SAMC on top of Broad and Auto SAMC. 

As presented in this thesis, so far we only focus on semantics that reduce
distributed interleavings. In LocDist SAMC, we will leverage semantics related
to local interleavings. For example, in \mr{3721}, the bug appears when a
reducerâ€™s fetcher thread runs faster than its merger thread that is against a
design assumption (fetcher usually runs slower due to network fetches, while
merger is fast due to in-memory operation). Here, it is unnecessary to
interleave every instance of data processing between the fetcher and merger;
interleaving the termination points of fetcher and merger might suffice. As
another example, thread interleavings in adding jobs to a queue might not
matter. Overall, understanding the semantics of local processing can help prune
down unnecessary exectuions.

